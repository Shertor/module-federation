# Переход на динамический режим

### Полезные ссылки
Динамический модуль:
```bash
ng add @angular-architects/module-federation --project mfe-[name] --port 4201 --type remote
```
Динамический шелл:
```bash
ng add @angular-architects/module-federation --project shell --port 4200 --type dynamic-host
```

[туториал](https://www.angulararchitects.io/en/aktuelles/dynamic-module-federation-with-angular/)

### Преобразовываем `projects/shell/webpack.config.js` в

(аналогично поступаем с остальными webpack.config.js в модулях)

```js
const {
  shareAll,
  withModuleFederationPlugin,
} = require("@angular-architects/module-federation/webpack");

module.exports = withModuleFederationPlugin({
  shared: {
    ...shareAll({
      singleton: true,
      strictVersion: true,
      requiredVersion: "auto",
    }),
  },
  sharedMappings: [""], // Имена общих элементов из библиотек (без этого они не создаются как синглтоны)
});
```

### Преобразовываем `projects\shell\src\main.ts` в 

```bash
import { loadManifest } from '@angular-architects/module-federation';
 
 loadManifest("/assets/mf.manifest.json")
   .catch(err => console.error(err))
   .then(_ => import('./bootstrap'))
   .catch(err => console.error(err));
```

### Создаем манифест `projects\shell\src\assets\mf.manifest.json` вида

```json
{
  "clock": {
    "remoteEntry": "http://localhost:4201/remoteEntry.js",
    "exposedModule": "./Module",
    "displayName": "Clock",
    "routePath": "clock",
    "ngModuleName": "IntegratedClockModule"
  }
}

```

### Удаляем старый роутинг `projects\shell\src\app\app-routing.module.ts`

### Создаем новый 
`projects\shell\src\app\app.routes.ts`

```ts
import { Routes } from "@angular/router";
import { HomeComponent } from "./home/home.component";

export const APP_ROUTES: Routes = [
  {
    path: "",
    component: HomeComponent,
    pathMatch: "full",
  },
];
```

При необходимости модули указать можно здесь
```bash
import { loadRemoteModule } from "@angular-architects/module-federation";

{
path: "flights",
loadChildren: () =>
    loadRemoteModule({
    type: "manifest",
    remoteName: "mfe1",
    exposedModule: "./Module",
    }).then((m) => m.FlightsModule),
},
```

### Корректируем `projects\shell\src\app\app.module.ts`

```ts
import { NgModule } from "@angular/core";
import { BrowserModule } from "@angular/platform-browser";
import { RouterModule } from "@angular/router";

import { APP_ROUTES } from "./app.routes";
import { AppComponent } from "./app.component";
import { HomeComponent } from "./home/home.component";

@NgModule({
  imports: [BrowserModule, RouterModule.forRoot(APP_ROUTES)],
  declarations: [AppComponent, HomeComponent],
  providers: [],
  bootstrap: [AppComponent],
})
export class AppModule {}
```
### Корректируем `projects\shell\src\app\app.component.ts`

```ts
export class AppComponent implements OnInit {
  title = "shell";

  remotes: CustomRemoteConfig[] = [];

  constructor(private router: Router) {}

  async ngOnInit(): Promise<void> {
    const manifest = getManifest<CustomManifest>();

    // Hint: Move this to an APP_INITIALIZER
    //  to avoid issues with deep linking
    const routes = buildRoutes(manifest);
    this.router.resetConfig(routes);

    this.remotes = Object.values(manifest);
  }
}
```

`Про APP_INITIALIZER будет ниже, на момент написания информации про это нет`

### Ссылки на роуты из манифеста можно заполнить например вот так:
```html
<li *ngFor="let remote of remotes">
  <a [routerLink]="remote.routePath">{{ remote.displayName }}</a>
</li>
```

### Cоздаем папку `projects\shell\src\app\utils` и в ней создаем

`projects\shell\src\app\utils\routes.ts`
```ts
import { loadRemoteModule } from "@angular-architects/module-federation";
import { Routes } from "@angular/router";
import { APP_ROUTES } from "../app.routes";
import { CustomManifest } from "./config";

export function buildRoutes(options: CustomManifest): Routes {
  const lazyRoutes: Routes = Object.keys(options).map((key) => {
    const entry = options[key];
    return {
      path: entry.routePath,
      loadChildren: () =>
        loadRemoteModule({
          type: "manifest",
          remoteName: key,
          exposedModule: entry.exposedModule,
        }).then((m) => m[entry.ngModuleName]),
    };
  });

  return [...APP_ROUTES, ...lazyRoutes];
}
```

`projects\shell\src\app\utils\config.ts`
```ts
import { Manifest, RemoteConfig } from "@angular-architects/module-federation";

export type CustomRemoteConfig = RemoteConfig & {
  exposedModule: string;
  displayName: string;
  routePath: string;
  ngModuleName: string;
};

export type CustomManifest = Manifest<CustomRemoteConfig>;
```

### В модуле нужна корретировка

```ts
const {
  shareAll,
  withModuleFederationPlugin,
} = require("@angular-architects/module-federation/webpack");

module.exports = withModuleFederationPlugin({
  name: "clock",

  exposes: {
    // Adjusted line:
    "./Module":
      "./projects/clock/src/app/integrated-clock/integrated-clock.module.ts",
  },

  shared: {
    ...shareAll({
      singleton: true,
      strictVersion: true,
      requiredVersion: "auto",
    }),
  },
});
```

### Файл `decl.d.ts` больше не нужен