# Плагины

В этом разделе компоненты, которые встраиваются в основное `shell` приложение называются плагинами. 

Во всех командах предполагается, что на уровень выше создан пустой Angular проект, и уже в нем выполняются команды. 

```bash
ng new microfrontend-example --create-application false --minimal
```

Ссылки: https://www.angulararchitects.io/aktuelles/dynamic-module-federation-with-angular-2/

## Разработка плагинов

Для подключения плагинов они должны быть внутри собирающегося проекта.

### ? Создание проекта и модуля, которой будет делиться плагинами 

Для создания проекта:

```bash
ng generate application mfe-[name] --routing --style scss
```

Далее его необходимо превратить в динамический модуль. Номер порта должен быть уникален и совпадать с тем, что будет указываться в манифесте импорта основного `shell` приложения.

```bash
ng add @angular-architects/module-federation --project mfe-[name] --port 4201 --type remote
```

По сути в проекте не нужен никакой дополнительный контект. Для удобства можно располагать компоненты внутри `app.component.html`.

Далее необходимо настроить `webpack.config.js`. Ниже представлен пример конфига с экспортом одного плагина и подключенным общим модулем `shared`.

```js
const {
  shareAll,
  withModuleFederationPlugin,
} = require("@angular-architects/module-federation/webpack");

module.exports = withModuleFederationPlugin({
  name: "mfePlugins",

  exposes: {
    './Plugin1': './projects/mfe-plugins/src/app/plugin1/plugin1.component.ts'
  },

  shared: {
    ...shareAll({
      singleton: true,
      strictVersion: true,
      requiredVersion: "auto",
    }),
  },
  sharedMappings: ["@shared"],
});
```

Экспорт плагина выполняется следующим образом:
```js
    './Plugin1': './projects/mfe-plugins/src/app/plugin1/plugin1.component.ts'
```

Импорт общего модуля:
```js
sharedMappings: ["@shared"],
```

### Создание нового плагина

Для создания плагина необходимо содать компонент внутри модуля.

```bash
ng generate component [plugin name] --project mfe-[name]
```

Файл `[plugin name].component.ts` должен быть `standalone` компонентом. Такой компонент должен включать `CommonModule` как импорт.

```ts
import { CommonModule } from "@angular/common";
import { Component } from "@angular/core";

/**
 * Standalone компонент, подключаемый в виде плагина в основное приложение
 * Для экспорта необходимо добавить его в `webpack.config.js`
 */
@Component({
  standalone: true,
  selector: "app-plugin1",
  templateUrl: "./plugin1.component.html",
  styleUrls: ["./plugin1.component.scss"],
  imports: [CommonModule],
})
export class Plugin1Component {
  constructor() {}
}
```

## Подключение плагинов

Для подключения плагинов потребуется несколько доработок основного модуля. Расположить их можно, например, в папке `utils/plugins`

Для начала необходимо создать прокси оболочку для импортируемых компонентов `plugin-proxy.component.ts`. `PluginOptions` это дополительный тип, который определяется в файле `plugin.ts` и представлен ниже. 

`plugin-proxy.component.ts`
```ts
import {
  Component,
  Input,
  OnChanges,
  ViewChild,
  ViewContainerRef,
  // ComponentFactoryResolver,
  // Injector,
  // Type,
} from "@angular/core";
import { loadRemoteModule } from "@angular-architects/module-federation";
import { PluginOptions } from "./plugin";

@Component({
  standalone: true,
  selector: "plugin-proxy",
  template: ` <ng-container #placeHolder></ng-container> `,
})
export class PluginProxyComponent implements OnChanges {
  @ViewChild("placeHolder", { read: ViewContainerRef, static: true })
  viewContainer!: ViewContainerRef;

  constructor() {}

  @Input() options!: PluginOptions;

  async ngOnChanges() {
    this.viewContainer.clear();

    const Component = await loadRemoteModule(this.options).then(
      (m) => m[this.options.componentName]
    );

    this.viewContainer.createComponent(Component);
  }
}
```

В этом файле указываются дополнительные поля для импорта плагинов, которые будут указаны в manifest. 

`plugin.ts`
```ts
import { LoadRemoteModuleOptions } from "@angular-architects/module-federation";

export type PluginOptions = LoadRemoteModuleOptions & {
  displayName: string;
  componentName: string;
};
```

Потребуется также `LookupService`, который будет подгружать манифест плагинов. В этом примере он использует `HttpClient` для загрузки .json манифеста.

`lookup.service.ts`
```ts
import { Injectable } from "@angular/core";
import { PluginOptions } from "./plugin";
import { HttpClient, HttpErrorResponse } from "@angular/common/http";
import { catchError, lastValueFrom, Observable, retry, throwError } from "rxjs";

@Injectable({ providedIn: "root" })
export class LookupService {
  manifestUrl = "../../assets/mf.plugins.manifest.json";
  manifest: PluginOptions[] | undefined;

  constructor(private http: HttpClient) {}
  lookup(): Promise<PluginOptions[]> {
    return lastValueFrom(
      this.http
        .get<PluginOptions[]>(this.manifestUrl)
        .pipe(retry(3), catchError(this.handleError))
    );
  }

  /**
   * Стандартный обработчик ошибок от RXJS
   */
  private handleError(error: HttpErrorResponse): Observable<never> {
    if (error.status === 0) {
      // A client-side or network error occurred. Handle it accordingly.
      console.error("An error occurred:", error.error);
    } else {
      // The backend returned an unsuccessful response code.
      // The response body may contain clues as to what went wrong.
      console.error(
        `Backend returned code ${error.status}, body was: `,
        error.error
      );
    }
    // Return an observable with a user-facing error message.
    return throwError(
      () => new Error("Something bad happened; please try again later.")
    );
  }
}
```

В `assets` лежит манифест для плагинов в файле `mf.plugins.manifest.json`

`mf.plugins.manifest.json`
```json
[
  {
    "type": "module",
    "remoteEntry": "http://localhost:[Module IP]/remoteEntry.js",
    "exposedModule": "./Plugin1",

    "displayName": "Plugin1",
    "componentName": "Plugin1Component" // Имя компонента должно соответствовать его именю класса
  },
]
```

Для того, чтобы подгрузить манифест и создать плагины из него можно сделать так:

В компоненте, в который будут вставляться плагины создаем переменную из `PluginOptions`:
```ts
  public plugins: PluginOptions[] = [];
  public isPluginsLoading: boolean = true;
```

Для подгрузки плагинов используется следующая конструкция:
`component.ts`
```ts
this.lookupService.lookup().then((plugins) => {
      this.isPluginsLoading = false;

      this.plugins = plugins;
    });
```

Создать компоненты можно, например, так:
`component.html`
```html
  <ng-container *ngFor="let p of plugins">
    <plugin-proxy [options]="p"></plugin-proxy>
  </ng-container>
```